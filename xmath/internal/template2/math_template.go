package template2

import "sort"

type MathConfig struct {
	Key         string
	HasNegative bool
}

func GetMathTPLArgs() interface{} {
	var mathConfigs = make([]MathConfig, 0)
	var types = []string{
		"int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64",
	}
	var hasNegatives = []string{
		"int", "int8", "int16", "int32", "int64",
		"float32", "float64",
	}
	var hasNegativeMapping = make(map[string]bool)
	for _, v := range hasNegatives {
		hasNegativeMapping[v] = true
	}
	for _, tk := range types {
		mathConfigs = append(mathConfigs, MathConfig{Key: tk, HasNegative: hasNegativeMapping[tk]})
	}
	sort.Slice(mathConfigs, func(i, j int) bool {
		return mathConfigs[i].Key < mathConfigs[j].Key
	})
	return map[string]interface{}{"MathConfigs": mathConfigs}
}

const MathTestTPL = `// Code generated by tools. DO NOT EDIT.
package xmath

import (
	. "github.com/smartystreets/goconvey/convey"
	"testing"
)

func TestMath(t *testing.T) {
	Convey("Float64Equals", t, func() {
		So(Float64Equals(0.1, 0.2), ShouldBeFalse)
		So(Float64Equals(0.1, 0.1+EPSILON64), ShouldBeTrue)
	})

	Convey("Float32Equals", t, func() {
		So(Float32Equals(0.1, 0.2), ShouldBeFalse)
		So(Float32Equals(0.1, 0.1+EPSILON32), ShouldBeTrue)
	})
	
	Convey("IsZeroFloat64", t, func() {
		So(IsZeroFloat64(0.1), ShouldBeFalse)
		So(IsZeroFloat64(0), ShouldBeTrue)
	})

	Convey("IsZeroFloat32", t, func() {
		So(IsZeroFloat32(0.1), ShouldBeFalse)
		So(IsZeroFloat32(0), ShouldBeTrue)
	})

	Convey("IsBelowZeroFloat64", t, func() {
		So(IsBelowZeroFloat64(0.1), ShouldBeFalse)
		So(IsBelowZeroFloat64(0), ShouldBeTrue)
		So(IsBelowZeroFloat64(-0.1), ShouldBeTrue)
	})

	Convey("IsBelowZeroFloat32", t, func() {
		So(IsBelowZeroFloat32(0.1), ShouldBeFalse)
		So(IsBelowZeroFloat32(0), ShouldBeTrue)
		So(IsBelowZeroFloat32(-0.1), ShouldBeTrue)
	})
{{ range $mathConfig := .MathConfigs }}
{{- $camelCaseKey := $mathConfig.Key | CamelCase}}
	Convey("{{ $camelCaseKey }}", t, func() {
{{- if or (eq $mathConfig.Key "float32") (eq $mathConfig.Key "float64") }}
		So(Max{{ $camelCaseKey }}(3.000000001, 3.000000002), ShouldEqual, 3.000000002)
		So(Min{{ $camelCaseKey }}(3.000000001, 3.000000002), ShouldEqual, 3.000000001)
	{{- if $mathConfig.HasNegative }}
		So(Abs{{ $camelCaseKey }}(3.000000001), ShouldEqual, 3.000000001)
		So(Abs{{ $camelCaseKey }}(-3.000000001), ShouldEqual, 3.000000001)
		So(EffectZeroLimit{{ $camelCaseKey }}(3.000000001, 0), ShouldEqual, 3.000000001)
		So(EffectZeroLimit{{ $camelCaseKey }}(3.000000001, -3.000000002), ShouldEqual, 0)
	{{- end }}
{{- else }}
		So(Max{{ $camelCaseKey }}(3, 2), ShouldEqual, 3)
		So(Min{{ $camelCaseKey }}(3, 2), ShouldEqual, 2)
	{{- if $mathConfig.HasNegative }}
		So(Abs{{ $camelCaseKey }}(3), ShouldEqual, 3)
		So(Abs{{ $camelCaseKey }}(-3), ShouldEqual, 3)
		So(EffectZeroLimit{{ $camelCaseKey }}(3, 0), ShouldEqual, 3)
		So(EffectZeroLimit{{ $camelCaseKey }}(3, -4), ShouldEqual, 0)
	{{- end }}
{{- end }}
	})
{{ end }}}
`

const MathTPL = `// Code generated by tools. DO NOT EDIT.
package xmath

import "math"

const (
	EPSILON64 float64 = 0.00000001
	EPSILON32 float32 = 0.00000001
)

// Integer limit values.
const (
	ConstMaxInt    = math.MaxInt
	ConstMinInt    = math.MinInt
	ConstMaxUint   = math.MaxUint
	ConstMaxInt8   = math.MaxInt8
	ConstMinInt8   = math.MinInt8
	ConstMaxInt16  = math.MaxInt16
	ConstMinInt16  = math.MinInt16
	ConstMaxInt32  = math.MaxInt32
	ConstMinInt32  = math.MinInt32
	ConstMaxInt64  = math.MaxInt64
	ConstMinInt64  = math.MinInt64
	ConstMaxUint8  = math.MaxUint8
	ConstMaxUint16 = math.MaxUint16
	ConstMaxUint32 = math.MaxUint32
	ConstMaxUint64 = math.MaxUint64
)

// Float64Equals 判断 float64 是否相等
func Float64Equals(a, b float64) bool {
	return (a-b) {{ "<" | Unescaped }} EPSILON64 && (b-a) {{ "<" | Unescaped }} EPSILON64
}

// Float32Equals 判断 float32 是否相等
func Float32Equals(a, b float32) bool {
	return (a-b) {{ "<" | Unescaped }} EPSILON32 && (b-a) {{ "<" | Unescaped }} EPSILON32
}

// IsZeroFloat64 判断 float64 是否是零值
func IsZeroFloat64(v float64) bool {
	return Float64Equals(v, 0)
}

// IsZeroFloat32 判断 float32 是否是零值
func IsZeroFloat32(v float32) bool {
	return Float32Equals(v, 0)
}

// IsBelowZeroFloat64 v == 0 时也返回true
func IsBelowZeroFloat64(v float64) bool {
	return (v - 0) {{ "<" | Unescaped }} EPSILON64
}

// IsBelowZeroFloat32 v == 0 时也返回true
func IsBelowZeroFloat32(v float32) bool {
	return (v - 0) {{ "<" | Unescaped }} EPSILON32
}
{{ range $mathConfig := .MathConfigs }}
{{- $camelCaseKey := $mathConfig.Key | CamelCase}}
// Max{{ $camelCaseKey }} 返回 {{ $mathConfig.Key }} 类型大值
func Max{{ $camelCaseKey }}(a, b {{ $mathConfig.Key }}) {{ $mathConfig.Key }} {
{{- if eq $mathConfig.Key "float32" }}
	return float32(math.Max(float64(a), float64(b)))
{{- else if eq $mathConfig.Key "float64" }}
	return math.Max(a, b)
{{- else }}
	if a > b {
		return a
	}
	return b
{{- end }}
}

// Min{{ $camelCaseKey }} 返回 {{ $mathConfig.Key }} 类型小值
func Min{{ $camelCaseKey }}(a, b {{ $mathConfig.Key }}) {{ $mathConfig.Key }} {
{{- if eq $mathConfig.Key "float32" }}
	return float32(math.Min(float64(a), float64(b)))
{{- else if eq $mathConfig.Key "float64" }}
	return math.Min(a, b)
{{- else }}
	if a {{ "<" | Unescaped }} b {
		return a
	}
	return b
{{- end }}
}
{{ if $mathConfig.HasNegative }}
// Abs{{ $camelCaseKey }} 返回 {{ $mathConfig.Key }} 类型绝对值
func Abs{{ $camelCaseKey }}(v {{ $mathConfig.Key }}) {{ $mathConfig.Key }} {
{{- if eq $mathConfig.Key "float32" }}
	if IsBelowZeroFloat32(v) {
{{- else if eq $mathConfig.Key "float64" }}
	if IsBelowZeroFloat64(v) {
{{- else }}
	if v {{ "<" | Unescaped }} 0 {
{{- end }}
		return -v
	}
	return v
}

// EffectZeroLimit{{ $camelCaseKey }} 加 change 值，返回 {{ $mathConfig.Key }} 类型值，该值不会小于0
func EffectZeroLimit{{ $camelCaseKey }}(v, change {{ $mathConfig.Key }}) {{ $mathConfig.Key }} {
	v += change
{{- if eq $mathConfig.Key "float32" }}
	if IsBelowZeroFloat32(v) {
{{- else if eq $mathConfig.Key "float64" }}
	if IsBelowZeroFloat64(v) {
{{- else }}
	if v {{ "<" | Unescaped }} 0 {
{{- end }}
		v = 0
	}
	return v
}
{{- end }}
{{ end }}
`
