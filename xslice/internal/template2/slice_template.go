package template2

import "sort"

type SliceConfig struct {
	Key string
}

func GetSliceTPLArgs() interface{} {
	var sliceConfigs = make([]SliceConfig, 0)
	var types = []string{
		"int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"string",
	}
	for _, tk := range types {
		sliceConfigs = append(sliceConfigs, SliceConfig{Key: tk})
	}
	sort.Slice(sliceConfigs, func(i, j int) bool {
		return sliceConfigs[i].Key < sliceConfigs[j].Key
	})
	return map[string]interface{}{"SliceConfigs": sliceConfigs}
}

const SliceTestTPL = `// Code generated by tools. DO NOT EDIT.
package xslice

import (
	. "github.com/smartystreets/goconvey/convey"
	"testing"
)

{{ range $sliceConfig := .SliceConfigs }}
{{- $camelCaseKey := $sliceConfig.Key | CamelCase }}
{{- $camelCaseName := print $camelCaseKey "s" }}
func Test{{ $camelCaseName }}(t *testing.T) {
	Convey("{{ $sliceConfig.Key }} slice", t, func() {
		for _, test := range []struct {
			ss 			[]{{ $sliceConfig.Key }}
			s           {{ $sliceConfig.Key }}
			contains    bool
		}{
{{- if eq $sliceConfig.Key "string" }}
			{ss: nil, s: "a"},
			{ss: []string{"abc", "b"}, s: "a", contains: false},
			{ss: []string{"abc", "b"}, s: "abc", contains: true},
{{- else }}
			{ss: nil, s: 1},
			{ss: []{{ $sliceConfig.Key }}{1, 2}, s: 3, contains: false},
			{ss: []{{ $sliceConfig.Key }}{1, 2}, s: 1, contains: true},
{{- end }}
		} {
			So({{ $camelCaseName }}Contain(test.ss, test.s), ShouldEqual, test.contains)
		}
{{- if eq $sliceConfig.Key "string" }}
		for _, test := range []struct {
			ss 		  []{{ $sliceConfig.Key }}
			s         {{ $sliceConfig.Key }}
			contains    bool
		}{
			{ss: nil, s: "a"},
			{ss: []{{ $sliceConfig.Key }}{"abc", "b"}, s: "a", contains: false},
			{ss: []{{ $sliceConfig.Key }}{"abc", "b"}, s: "abc", contains: true},
			{ss: []{{ $sliceConfig.Key }}{"ABC", "b"}, s: "abc", contains: true},
		} {
			So({{ $camelCaseName }}ContainEqualFold(test.ss, test.s), ShouldEqual, test.contains)
		}
{{- end }}
{{- if eq $sliceConfig.Key "string" }}
		dest := {{ $camelCaseName }}SetAdd(nil, "a")
		So(len(dest), ShouldEqual, 1)
		So(len({{ $camelCaseName }}SetAdd(dest, "a")), ShouldEqual, 1)

		src := []{{ $sliceConfig.Key }}{"1", "2"}
		dest = {{ $camelCaseName }}Walk(src, func(s {{ $sliceConfig.Key }}) ({{ $sliceConfig.Key }}, bool) {
			return s + ",", true
		})
		So(len(src), ShouldEqual, len(dest))
		for i := 0; i {{ "<" | Unescaped }} len(src); i++ {
			So(src[i]+",", ShouldEqual, dest[i])
		}

		dest = {{ $camelCaseName }}AddSuffix(src, ",")
		So(len(src), ShouldEqual, len(dest))
		for i := 0; i {{ "<" | Unescaped }} len(src); i++ {
			So(src[i]+",", ShouldEqual, dest[i])
		}

		dest = {{ $camelCaseName }}AddPrefix(src, ",")
		So(len(src), ShouldEqual, len(dest))
		for i := 0; i {{ "<" | Unescaped }} len(src); i++ {
			So(","+src[i], ShouldEqual, dest[i])
		}
{{- else }}
		dest := {{ $camelCaseName }}SetAdd(nil, 1)
		So(len(dest), ShouldEqual, 1)
		So(len({{ $camelCaseName }}SetAdd(dest, 1)), ShouldEqual, 1)

		src := []{{ $sliceConfig.Key }}{1, 2}
		dest = {{ $camelCaseName }}Walk(src, func(s {{ $sliceConfig.Key }}) ({{ $sliceConfig.Key }}, bool) {
			return s + 1, true
		})
		So(len(src), ShouldEqual, len(dest))
		for i := 0; i {{ "<" | Unescaped }} len(src); i++ {
			So(src[i]+1, ShouldEqual, dest[i])
		}
{{- end }}
		tooManyElement = 4
		for _, test := range []struct {
			src      []{{ $sliceConfig.Key }}
			dest     []{{ $sliceConfig.Key }}
			contains bool
		}{
{{- if eq $sliceConfig.Key "string" }}
			{src: []{{ $sliceConfig.Key }}{"abc", "b", "b"}, dest: []{{ $sliceConfig.Key }}{"abc", "b"}},
			{src: []{{ $sliceConfig.Key }}{"abc", "abc", "b"}, dest: []{{ $sliceConfig.Key }}{"abc", "b"}},
			{src: []{{ $sliceConfig.Key }}{"abc", "abc", "b", "b", "b"}, dest: []{{ $sliceConfig.Key }}{"abc", "b"}},
{{- else }}
			{src: []{{ $sliceConfig.Key }}{1, 2, 2}, dest: []{{ $sliceConfig.Key }}{1, 2}},
			{src: []{{ $sliceConfig.Key }}{1, 1, 2}, dest: []{{ $sliceConfig.Key }}{1, 2}},
			{src: []{{ $sliceConfig.Key }}{1, 1, 2, 2, 2}, dest: []{{ $sliceConfig.Key }}{1, 2}},
{{- end }}
		} {
			So({{ $camelCaseName }}RemoveRepeated(test.src), ShouldResemble, test.dest)
		}

		for _, test := range []struct {
			src      []{{ $sliceConfig.Key }}
			dest     []{{ $sliceConfig.Key }}
			contains bool
		}{
{{- if eq $sliceConfig.Key "string" }}
			{src: []{{ $sliceConfig.Key }}{"abc", "", "b"}, dest: []{{ $sliceConfig.Key }}{"abc", "b"}},
			{src: []{{ $sliceConfig.Key }}{"abc", "abc", ""}, dest: []{{ $sliceConfig.Key }}{"abc", "abc"}},
			{src: []{{ $sliceConfig.Key }}{"abc", "", "", "b", ""}, dest: []{{ $sliceConfig.Key }}{"abc", "b"}},
{{- else }}
			{src: []{{ $sliceConfig.Key }}{1, 0, 2}, dest: []{{ $sliceConfig.Key }}{1, 2}},
			{src: []{{ $sliceConfig.Key }}{1, 1, 0}, dest: []{{ $sliceConfig.Key }}{1, 1}},
			{src: []{{ $sliceConfig.Key }}{1, 0, 0, 2, 0}, dest: []{{ $sliceConfig.Key }}{1, 2}},
{{- end }}
		} {
			So({{ $camelCaseName }}RemoveEmpty(test.src), ShouldResemble, test.dest)
		}
	})
}
{{ end }}
`

const SliceTPL = `// Code generated by tools. DO NOT EDIT.
package xslice

import "strings"

var (
	_ strings.Reader
	tooManyElement = 1024
)
 
{{ range $sliceConfig := .SliceConfigs }}
{{- $camelCaseKey := $sliceConfig.Key | CamelCase }}
{{- $camelCaseName := print $camelCaseKey "s" }}
// {{ $camelCaseName }}Contain s 中是否含有指定元素 v
func {{ $camelCaseName }}Contain(s []{{ $sliceConfig.Key }}, v {{ $sliceConfig.Key }}) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

{{- if eq $sliceConfig.Key "string" }}
// {{ $camelCaseName }}ContainEqualFold s 中是否含有指定元素 v，不区分大小写
func {{ $camelCaseName }}ContainEqualFold(s []{{ $sliceConfig.Key }}, v {{ $sliceConfig.Key }}) bool {
	for _, ele := range s {
		if strings.EqualFold(ele, v) {
			return true
		}
	}
	return false
}
{{- end }}

// {{ $camelCaseName }}SetAdd 如果 s 中不存在给定的元素 v 则添加
func {{ $camelCaseName }}SetAdd(s []{{ $sliceConfig.Key }}, v ...{{ $sliceConfig.Key }}) []{{ $sliceConfig.Key }} {
	for _, ele := range v {
		if !{{ $camelCaseKey }}sContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// {{ $camelCaseName }}Walk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func {{ $camelCaseName }}Walk(s []{{ $sliceConfig.Key }}, f func({{ $sliceConfig.Key }}) ({{ $sliceConfig.Key }}, bool)) []{{ $sliceConfig.Key }} {
	out := make([]{{ $sliceConfig.Key }}, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

{{- if eq $sliceConfig.Key "string" }}
// {{ $camelCaseName }}AddPrefix 每一个元素添加前缀
func {{ $camelCaseName }}AddPrefix(s []{{ $sliceConfig.Key }}, prefix {{ $sliceConfig.Key }}) []{{ $sliceConfig.Key }} {
	out := make([]{{ $sliceConfig.Key }}, 0, len(s))
	for _, ele := range s {
		out = append(out, prefix+ele)
	}
	return out
}

// {{ $camelCaseName }}AddSuffix 每一个元素添加后缀
func {{ $camelCaseName }}AddSuffix(s []{{ $sliceConfig.Key }}, suffix {{ $sliceConfig.Key }}) []{{ $sliceConfig.Key }} {
	out := make([]{{ $sliceConfig.Key }}, 0, len(s))
	for _, ele := range s {
		out = append(out, ele+suffix)
	}
	return out
}
{{- end }}

// {{ $camelCaseName }}RemoveRepeated 移除重复元素
func {{ $camelCaseName }}RemoveRepeated(s []{{ $sliceConfig.Key }}) []{{ $sliceConfig.Key }} {
	if len(s) == 0 {
		return s
	}
	if len(s) {{ "<" | Unescaped }} tooManyElement {
		return {{ $sliceConfig.Key }}RemoveRepeatByLoop(s)
	} else {
		return {{ $sliceConfig.Key }}RemoveRepeatByMap(s)
	}
}

// {{ $camelCaseName }}RemoveEmpty 移除空元素
func {{ $camelCaseName }}RemoveEmpty(s []{{ $sliceConfig.Key }}) []{{ $sliceConfig.Key }} {
	out := make([]{{ $sliceConfig.Key }}, 0, len(s))
	for _, ele := range s {
{{- if eq $sliceConfig.Key "string" }}
		if len(ele) > 0 {
{{- else }}
		if ele != 0 {
{{- end }}
			out = append(out, ele)
		}
	}
	return out
}

func {{ $sliceConfig.Key }}RemoveRepeatByMap(s []{{ $sliceConfig.Key }}) []{{ $sliceConfig.Key }} {
	out := make([]{{ $sliceConfig.Key }}, 0, len(s))
	tmp := make(map[{{ $sliceConfig.Key }}]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func {{ $sliceConfig.Key }}RemoveRepeatByLoop(s []{{ $sliceConfig.Key }}) []{{ $sliceConfig.Key }} {
	out := make([]{{ $sliceConfig.Key }}, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false 
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}
{{ end }}
`
