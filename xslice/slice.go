// Code generated by tools. DO NOT EDIT.
package xslice

import "strings"

var (
	_              strings.Reader
	tooManyElement = 1024
)

// IntsContain s 中是否含有指定元素 v
func IntsContain(s []int, v int) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// IntsSetAdd 如果 s 中不存在给定的元素 v 则添加
func IntsSetAdd(s []int, v ...int) []int {
	for _, ele := range v {
		if !IntsContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// IntsWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func IntsWalk(s []int, f func(int) (int, bool)) []int {
	out := make([]int, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// IntsRemoveRepeated 移除重复元素
func IntsRemoveRepeated(s []int) []int {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return intRemoveRepeatByLoop(s)
	} else {
		return intRemoveRepeatByMap(s)
	}
}

// IntsRemoveEmpty 移除空元素
func IntsRemoveEmpty(s []int) []int {
	out := make([]int, 0, len(s))
	for _, ele := range s {
		if ele != 0 {
			out = append(out, ele)
		}
	}
	return out
}

func intRemoveRepeatByMap(s []int) []int {
	out := make([]int, 0, len(s))
	tmp := make(map[int]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func intRemoveRepeatByLoop(s []int) []int {
	out := make([]int, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}

// Int16sContain s 中是否含有指定元素 v
func Int16sContain(s []int16, v int16) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// Int16sSetAdd 如果 s 中不存在给定的元素 v 则添加
func Int16sSetAdd(s []int16, v ...int16) []int16 {
	for _, ele := range v {
		if !Int16sContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// Int16sWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func Int16sWalk(s []int16, f func(int16) (int16, bool)) []int16 {
	out := make([]int16, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// Int16sRemoveRepeated 移除重复元素
func Int16sRemoveRepeated(s []int16) []int16 {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return int16RemoveRepeatByLoop(s)
	} else {
		return int16RemoveRepeatByMap(s)
	}
}

// Int16sRemoveEmpty 移除空元素
func Int16sRemoveEmpty(s []int16) []int16 {
	out := make([]int16, 0, len(s))
	for _, ele := range s {
		if ele != 0 {
			out = append(out, ele)
		}
	}
	return out
}

func int16RemoveRepeatByMap(s []int16) []int16 {
	out := make([]int16, 0, len(s))
	tmp := make(map[int16]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func int16RemoveRepeatByLoop(s []int16) []int16 {
	out := make([]int16, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}

// Int32sContain s 中是否含有指定元素 v
func Int32sContain(s []int32, v int32) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// Int32sSetAdd 如果 s 中不存在给定的元素 v 则添加
func Int32sSetAdd(s []int32, v ...int32) []int32 {
	for _, ele := range v {
		if !Int32sContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// Int32sWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func Int32sWalk(s []int32, f func(int32) (int32, bool)) []int32 {
	out := make([]int32, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// Int32sRemoveRepeated 移除重复元素
func Int32sRemoveRepeated(s []int32) []int32 {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return int32RemoveRepeatByLoop(s)
	} else {
		return int32RemoveRepeatByMap(s)
	}
}

// Int32sRemoveEmpty 移除空元素
func Int32sRemoveEmpty(s []int32) []int32 {
	out := make([]int32, 0, len(s))
	for _, ele := range s {
		if ele != 0 {
			out = append(out, ele)
		}
	}
	return out
}

func int32RemoveRepeatByMap(s []int32) []int32 {
	out := make([]int32, 0, len(s))
	tmp := make(map[int32]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func int32RemoveRepeatByLoop(s []int32) []int32 {
	out := make([]int32, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}

// Int64sContain s 中是否含有指定元素 v
func Int64sContain(s []int64, v int64) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// Int64sSetAdd 如果 s 中不存在给定的元素 v 则添加
func Int64sSetAdd(s []int64, v ...int64) []int64 {
	for _, ele := range v {
		if !Int64sContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// Int64sWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func Int64sWalk(s []int64, f func(int64) (int64, bool)) []int64 {
	out := make([]int64, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// Int64sRemoveRepeated 移除重复元素
func Int64sRemoveRepeated(s []int64) []int64 {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return int64RemoveRepeatByLoop(s)
	} else {
		return int64RemoveRepeatByMap(s)
	}
}

// Int64sRemoveEmpty 移除空元素
func Int64sRemoveEmpty(s []int64) []int64 {
	out := make([]int64, 0, len(s))
	for _, ele := range s {
		if ele != 0 {
			out = append(out, ele)
		}
	}
	return out
}

func int64RemoveRepeatByMap(s []int64) []int64 {
	out := make([]int64, 0, len(s))
	tmp := make(map[int64]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func int64RemoveRepeatByLoop(s []int64) []int64 {
	out := make([]int64, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}

// Int8sContain s 中是否含有指定元素 v
func Int8sContain(s []int8, v int8) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// Int8sSetAdd 如果 s 中不存在给定的元素 v 则添加
func Int8sSetAdd(s []int8, v ...int8) []int8 {
	for _, ele := range v {
		if !Int8sContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// Int8sWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func Int8sWalk(s []int8, f func(int8) (int8, bool)) []int8 {
	out := make([]int8, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// Int8sRemoveRepeated 移除重复元素
func Int8sRemoveRepeated(s []int8) []int8 {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return int8RemoveRepeatByLoop(s)
	} else {
		return int8RemoveRepeatByMap(s)
	}
}

// Int8sRemoveEmpty 移除空元素
func Int8sRemoveEmpty(s []int8) []int8 {
	out := make([]int8, 0, len(s))
	for _, ele := range s {
		if ele != 0 {
			out = append(out, ele)
		}
	}
	return out
}

func int8RemoveRepeatByMap(s []int8) []int8 {
	out := make([]int8, 0, len(s))
	tmp := make(map[int8]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func int8RemoveRepeatByLoop(s []int8) []int8 {
	out := make([]int8, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}

// StringsContain s 中是否含有指定元素 v
func StringsContain(s []string, v string) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// StringsContainEqualFold s 中是否含有指定元素 v，不区分大小写
func StringsContainEqualFold(s []string, v string) bool {
	for _, ele := range s {
		if strings.EqualFold(ele, v) {
			return true
		}
	}
	return false
}

// StringsSetAdd 如果 s 中不存在给定的元素 v 则添加
func StringsSetAdd(s []string, v ...string) []string {
	for _, ele := range v {
		if !StringsContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// StringsWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func StringsWalk(s []string, f func(string) (string, bool)) []string {
	out := make([]string, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// StringsAddPrefix 每一个元素添加前缀
func StringsAddPrefix(s []string, prefix string) []string {
	out := make([]string, 0, len(s))
	for _, ele := range s {
		out = append(out, prefix+ele)
	}
	return out
}

// StringsAddSuffix 每一个元素添加后缀
func StringsAddSuffix(s []string, suffix string) []string {
	out := make([]string, 0, len(s))
	for _, ele := range s {
		out = append(out, ele+suffix)
	}
	return out
}

// StringsRemoveRepeated 移除重复元素
func StringsRemoveRepeated(s []string) []string {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return stringRemoveRepeatByLoop(s)
	} else {
		return stringRemoveRepeatByMap(s)
	}
}

// StringsRemoveEmpty 移除空元素
func StringsRemoveEmpty(s []string) []string {
	out := make([]string, 0, len(s))
	for _, ele := range s {
		if len(ele) > 0 {
			out = append(out, ele)
		}
	}
	return out
}

func stringRemoveRepeatByMap(s []string) []string {
	out := make([]string, 0, len(s))
	tmp := make(map[string]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func stringRemoveRepeatByLoop(s []string) []string {
	out := make([]string, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}

// UintsContain s 中是否含有指定元素 v
func UintsContain(s []uint, v uint) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// UintsSetAdd 如果 s 中不存在给定的元素 v 则添加
func UintsSetAdd(s []uint, v ...uint) []uint {
	for _, ele := range v {
		if !UintsContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// UintsWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func UintsWalk(s []uint, f func(uint) (uint, bool)) []uint {
	out := make([]uint, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// UintsRemoveRepeated 移除重复元素
func UintsRemoveRepeated(s []uint) []uint {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return uintRemoveRepeatByLoop(s)
	} else {
		return uintRemoveRepeatByMap(s)
	}
}

// UintsRemoveEmpty 移除空元素
func UintsRemoveEmpty(s []uint) []uint {
	out := make([]uint, 0, len(s))
	for _, ele := range s {
		if ele != 0 {
			out = append(out, ele)
		}
	}
	return out
}

func uintRemoveRepeatByMap(s []uint) []uint {
	out := make([]uint, 0, len(s))
	tmp := make(map[uint]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func uintRemoveRepeatByLoop(s []uint) []uint {
	out := make([]uint, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}

// Uint16sContain s 中是否含有指定元素 v
func Uint16sContain(s []uint16, v uint16) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// Uint16sSetAdd 如果 s 中不存在给定的元素 v 则添加
func Uint16sSetAdd(s []uint16, v ...uint16) []uint16 {
	for _, ele := range v {
		if !Uint16sContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// Uint16sWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func Uint16sWalk(s []uint16, f func(uint16) (uint16, bool)) []uint16 {
	out := make([]uint16, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// Uint16sRemoveRepeated 移除重复元素
func Uint16sRemoveRepeated(s []uint16) []uint16 {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return uint16RemoveRepeatByLoop(s)
	} else {
		return uint16RemoveRepeatByMap(s)
	}
}

// Uint16sRemoveEmpty 移除空元素
func Uint16sRemoveEmpty(s []uint16) []uint16 {
	out := make([]uint16, 0, len(s))
	for _, ele := range s {
		if ele != 0 {
			out = append(out, ele)
		}
	}
	return out
}

func uint16RemoveRepeatByMap(s []uint16) []uint16 {
	out := make([]uint16, 0, len(s))
	tmp := make(map[uint16]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func uint16RemoveRepeatByLoop(s []uint16) []uint16 {
	out := make([]uint16, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}

// Uint32sContain s 中是否含有指定元素 v
func Uint32sContain(s []uint32, v uint32) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// Uint32sSetAdd 如果 s 中不存在给定的元素 v 则添加
func Uint32sSetAdd(s []uint32, v ...uint32) []uint32 {
	for _, ele := range v {
		if !Uint32sContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// Uint32sWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func Uint32sWalk(s []uint32, f func(uint32) (uint32, bool)) []uint32 {
	out := make([]uint32, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// Uint32sRemoveRepeated 移除重复元素
func Uint32sRemoveRepeated(s []uint32) []uint32 {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return uint32RemoveRepeatByLoop(s)
	} else {
		return uint32RemoveRepeatByMap(s)
	}
}

// Uint32sRemoveEmpty 移除空元素
func Uint32sRemoveEmpty(s []uint32) []uint32 {
	out := make([]uint32, 0, len(s))
	for _, ele := range s {
		if ele != 0 {
			out = append(out, ele)
		}
	}
	return out
}

func uint32RemoveRepeatByMap(s []uint32) []uint32 {
	out := make([]uint32, 0, len(s))
	tmp := make(map[uint32]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func uint32RemoveRepeatByLoop(s []uint32) []uint32 {
	out := make([]uint32, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}

// Uint64sContain s 中是否含有指定元素 v
func Uint64sContain(s []uint64, v uint64) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// Uint64sSetAdd 如果 s 中不存在给定的元素 v 则添加
func Uint64sSetAdd(s []uint64, v ...uint64) []uint64 {
	for _, ele := range v {
		if !Uint64sContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// Uint64sWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func Uint64sWalk(s []uint64, f func(uint64) (uint64, bool)) []uint64 {
	out := make([]uint64, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// Uint64sRemoveRepeated 移除重复元素
func Uint64sRemoveRepeated(s []uint64) []uint64 {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return uint64RemoveRepeatByLoop(s)
	} else {
		return uint64RemoveRepeatByMap(s)
	}
}

// Uint64sRemoveEmpty 移除空元素
func Uint64sRemoveEmpty(s []uint64) []uint64 {
	out := make([]uint64, 0, len(s))
	for _, ele := range s {
		if ele != 0 {
			out = append(out, ele)
		}
	}
	return out
}

func uint64RemoveRepeatByMap(s []uint64) []uint64 {
	out := make([]uint64, 0, len(s))
	tmp := make(map[uint64]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func uint64RemoveRepeatByLoop(s []uint64) []uint64 {
	out := make([]uint64, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}

// Uint8sContain s 中是否含有指定元素 v
func Uint8sContain(s []uint8, v uint8) bool {
	for _, ele := range s {
		if ele == v {
			return true
		}
	}
	return false
}

// Uint8sSetAdd 如果 s 中不存在给定的元素 v 则添加
func Uint8sSetAdd(s []uint8, v ...uint8) []uint8 {
	for _, ele := range v {
		if !Uint8sContain(s, ele) {
			s = append(s, ele)
		}
	}
	return s
}

// Uint8sWalk 遍历 s 将 f 应用到每一个元素，返回更新后的数据
func Uint8sWalk(s []uint8, f func(uint8) (uint8, bool)) []uint8 {
	out := make([]uint8, 0, len(s))
	for _, ele := range s {
		if ret, valid := f(ele); valid {
			out = append(out, ret)
		}
	}
	return out
}

// Uint8sRemoveRepeated 移除重复元素
func Uint8sRemoveRepeated(s []uint8) []uint8 {
	if len(s) == 0 {
		return s
	}
	if len(s) < tooManyElement {
		return uint8RemoveRepeatByLoop(s)
	} else {
		return uint8RemoveRepeatByMap(s)
	}
}

// Uint8sRemoveEmpty 移除空元素
func Uint8sRemoveEmpty(s []uint8) []uint8 {
	out := make([]uint8, 0, len(s))
	for _, ele := range s {
		if ele != 0 {
			out = append(out, ele)
		}
	}
	return out
}

func uint8RemoveRepeatByMap(s []uint8) []uint8 {
	out := make([]uint8, 0, len(s))
	tmp := make(map[uint8]struct{})
	for _, ele := range s {
		l := len(tmp)
		tmp[ele] = struct{}{}
		if len(tmp) != l {
			out = append(out, ele)
		}
	}
	return out
}

func uint8RemoveRepeatByLoop(s []uint8) []uint8 {
	out := make([]uint8, 0, len(s))
	flag := true
	for i := range s {
		flag = true
		for j := range out {
			if s[i] == out[j] {
				flag = false
				break
			}
		}
		if flag {
			out = append(out, s[i])
		}
	}
	return out
}
