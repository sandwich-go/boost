package template2

const GeomTestTPL = `// Code generated by tools. DO NOT EDIT.
package geom

import (
	. "github.com/smartystreets/goconvey/convey"
	"testing"
)

{{- $camelCaseKey := .Key | CamelCase }}
{{- $pointName := print "Point" $camelCaseKey }}
func TestRectangle{{ $camelCaseKey }}_SnakeRange(t *testing.T) {
	HelixRectRangeFromCenterAndMargin{{ $camelCaseKey }}(Pt{{ $camelCaseKey }}(2, 2), 2, func(p {{ $pointName }}) bool {
		t.Log(p.X, p.Y)
		return true
	})

	Convey("test intersection with line", t, func() {
		rect := Rect{{ $camelCaseKey }}(0, 0, 3, 3)
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(1, 0), Pt{{ $camelCaseKey }}(1, 4)), ShouldBeTrue)  // should be true
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(1, 0), Pt{{ $camelCaseKey }}(1, 3)), ShouldBeTrue)  // should be true
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(1, 0), Pt{{ $camelCaseKey }}(1, 2)), ShouldBeTrue)  // should be true
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(1, 0), Pt{{ $camelCaseKey }}(1, 1)), ShouldBeTrue)  // should be true
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(2, 0), Pt{{ $camelCaseKey }}(2, 2)), ShouldBeTrue)  // should be true
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(0, 2), Pt{{ $camelCaseKey }}(1, 2)), ShouldBeTrue)  // should be true
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(0, 1), Pt{{ $camelCaseKey }}(3, 1)), ShouldBeTrue)  // should be true
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(0, 0), Pt{{ $camelCaseKey }}(0, 1)), ShouldBeFalse) // should be false
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(0, 0), Pt{{ $camelCaseKey }}(0, 2)), ShouldBeFalse) // should be false
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(0, 0), Pt{{ $camelCaseKey }}(0, 3)), ShouldBeFalse) // should be false
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(0, 0), Pt{{ $camelCaseKey }}(0, 4)), ShouldBeFalse) // should be false
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(0, 0), Pt{{ $camelCaseKey }}(1, 0)), ShouldBeFalse) // should be false
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(0, 0), Pt{{ $camelCaseKey }}(2, 0)), ShouldBeFalse) // should be false
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(1, 4), Pt{{ $camelCaseKey }}(2, 4)), ShouldBeFalse) // should be false
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(0, 3), Pt{{ $camelCaseKey }}(3, 3)), ShouldBeFalse) // should be false
		So(rect.IntersectionWithLine(Pt{{ $camelCaseKey }}(1, 3), Pt{{ $camelCaseKey }}(2, 4)), ShouldBeFalse) // should be false
	})
}
`

const GeomTPL = `// Code generated by tools. DO NOT EDIT.
package geom

import "strconv"

{{- $camelCaseKey := .Key | CamelCase }}
{{- $pointName := print "Point" $camelCaseKey }}
{{- $rectangleName := print "Rectangle" $camelCaseKey }}
type {{ $pointName }} struct {
	X, Y {{ .Key }}
}

// String returns a string representation of p like "(3,4)".
func (p {{ $pointName }}) String() string {
	return "(" + strconv.FormatInt(int64(p.X), 10) + "," + strconv.FormatInt(int64(p.Y), 10) + ")"
}

// Add returns the vector p+q.
func (p {{ $pointName }}) Add(q {{ $pointName }}) {{ $pointName }} {
	return {{ $pointName }}{p.X + q.X, p.Y + q.Y}
}

// Sub returns the vector p-q.
func (p {{ $pointName }}) Sub(q {{ $pointName }}) {{ $pointName }} {
	return {{ $pointName }}{p.X - q.X, p.Y - q.Y}
}

// Mul returns the vector p*k.
func (p {{ $pointName }}) Mul(k {{ .Key }}) {{ $pointName }} {
	return {{ $pointName }}{p.X * k, p.Y * k}
}

// Div returns the vector p/k.
func (p {{ $pointName }}) Div(k {{ .Key }}) {{ $pointName }} {
	return {{ $pointName }}{p.X / k, p.Y / k}
}

// In reports whether p is in r.
func (p {{ $pointName }}) In(r {{ $rectangleName }}) bool {
	return r.Min.X {{ "<=" | Unescaped }} p.X && p.X {{ "<=" | Unescaped }} r.Max.X && r.Min.Y {{ "<=" | Unescaped }} p.Y && p.Y {{ "<=" | Unescaped }} r.Max.Y
}

// Eq reports whether p and q are equal.
func (p {{ $pointName }}) Eq(q {{ $pointName }}) bool {
	return p == q
}

// ZP{{ $camelCaseKey }} is the zero {{ $pointName }}.
var ZP{{ $camelCaseKey }} {{ $pointName }}

// Pt{{ $camelCaseKey }} is shorthand for {{ $pointName }}.{X, Y}.
func Pt{{ $camelCaseKey }}(X, Y {{ .Key }}) {{ $pointName }} {
	return {{ $pointName }}{X, Y}
}

type {{ $rectangleName }} struct {
	Min, Max {{ $pointName }}
}

// String returns a string representation of r like "(3,4)-(6,5)".
func (r {{ $rectangleName }}) String() string {
	return r.Min.String() + "-" + r.Max.String()
}

func (r {{ $rectangleName }}) RangePoints(with func(p {{ $pointName }}) bool) {
	if with == nil || r == ZR{{ $camelCaseKey }} {
		return
	}
	for x := r.Min.X; x {{ "<=" | Unescaped }} r.Max.X; x++ {
		for y := r.Min.Y; y {{ "<=" | Unescaped }} r.Max.Y; y++ {
			if !with(Pt{{ $camelCaseKey }}(x, y)) {
				return
			}
		}
	}
}

func (r {{ $rectangleName }}) RangePointsMinClosedMaxOpen(with func(p {{ $pointName }}) bool) {
	if with == nil || r == ZR{{ $camelCaseKey }} {
		return
	}
	for x := r.Min.X + 1; x {{ "<=" | Unescaped }} r.Max.X; x++ {
		for y := r.Min.Y + 1; y {{ "<=" | Unescaped }} r.Max.Y; y++ {
			if !with(Pt{{ $camelCaseKey }}(x, y)) {
				return
			}
		}
	}
}

func (r {{ $rectangleName }}) IntersectionWithLine(s {{ $pointName }}, e {{ $pointName }}) bool {
	if s.X {{ "<=" | Unescaped }} r.Min.X && e.X {{ "<=" | Unescaped }} r.Min.X || s.X >= r.Max.X && e.X >= r.Max.X || s.Y {{ "<=" | Unescaped }} r.Min.Y && e.Y {{ "<=" | Unescaped }} r.Min.Y || s.Y >= r.Max.Y && e.Y >= r.Max.Y {
		return false
	}
	a := s.Y - e.Y
	b := e.X - s.X
	c := e.Y*s.X - e.X*s.Y
	if ((a*r.Min.X+b*r.Min.Y+c)*(a*r.Max.X+b*r.Max.Y+c)) {{ "<=" | Unescaped }} 0 || ((a*r.Max.X+b*r.Min.Y+c)*(a*r.Min.X+b*r.Max.Y+c)) {{ "<=" | Unescaped }} 0 {
		return true
	}
	return false
}

func (r {{ $rectangleName }}) RangePointsMinMaxClosed(with func(p {{ $pointName }}) bool) {
	if with == nil || r == ZR{{ $camelCaseKey }} {
		return
	}
	for x := r.Min.X + 1; x {{ "<" | Unescaped }} r.Max.X; x++ {
		for y := r.Min.Y + 1; y {{ "<" | Unescaped }} r.Max.Y; y++ {
			if !with(Pt{{ $camelCaseKey }}(x, y)) {
				return
			}
		}
	}
}

func (r {{ $rectangleName }}) RangePointsMinOpenMaxClosed(with func(p {{ $pointName }}) bool) {
	if with == nil || r == ZR{{ $camelCaseKey }} {
		return
	}
	for x := r.Min.X; x {{ "<" | Unescaped }} r.Max.X; x++ {
		for y := r.Min.Y; y {{ "<" | Unescaped }} r.Max.Y; y++ {
			if !with(Pt{{ $camelCaseKey }}(x, y)) {
				return
			}
		}
	}
}

// Dx returns r's width.
func (r {{ $rectangleName }}) Dx() {{ .Key }} {
	return r.Max.X - r.Min.X
}

// Dy returns r's height.
func (r {{ $rectangleName }}) Dy() {{ .Key }} {
	return r.Max.Y - r.Min.Y
}

// Size returns r's width and height.
func (r {{ $rectangleName }}) Size() {{ $pointName }} {
	return {{ $pointName }}{
		r.Max.X - r.Min.X,
		r.Max.Y - r.Min.Y,
	}
}

// Add returns the rectangle r translated by p.
func (r {{ $rectangleName }}) Add(p {{ $pointName }}) {{ $rectangleName }} {
	return {{ $rectangleName }}{
		{{ $pointName }}{r.Min.X + p.X, r.Min.Y + p.Y},
		{{ $pointName }}{r.Max.X + p.X, r.Max.Y + p.Y},
	}
}

// Sub returns the rectangle r translated by -p.
func (r {{ $rectangleName }}) Sub(p {{ $pointName }}) {{ $rectangleName }} {
	return {{ $rectangleName }}{
		{{ $pointName }}{r.Min.X - p.X, r.Min.Y - p.Y},
		{{ $pointName }}{r.Max.X - p.X, r.Max.Y - p.Y},
	}
}

// Inset returns the rectangle r inset by n, which may be negative. If either
// of r's dimensions is less than 2*n then an empty rectangle near the center
// of r will be returned.
func (r {{ $rectangleName }}) Inset(n {{ .Key }}) {{ $rectangleName }} {
	if r.Dx() {{ "<" | Unescaped }} 2*n {
		r.Min.X = (r.Min.X + r.Max.X) / 2
		r.Max.X = r.Min.X
	} else {
		r.Min.X += n
		r.Max.X -= n
	}
	if r.Dy() {{ "<" | Unescaped }} 2*n {
		r.Min.Y = (r.Min.Y + r.Max.Y) / 2
		r.Max.Y = r.Min.Y
	} else {
		r.Min.Y += n
		r.Max.Y -= n
	}
	return r
}

// Intersect returns the largest rectangle contained by both r and s. If the
// two rectangles do not overlap then the zero rectangle will be returned.
func (r {{ $rectangleName }}) Intersect(s {{ $rectangleName }}) {{ $rectangleName }} {
	if r.Min.X {{ "<" | Unescaped }} s.Min.X {
		r.Min.X = s.Min.X
	}
	if r.Min.Y {{ "<" | Unescaped }} s.Min.Y {
		r.Min.Y = s.Min.Y
	}
	if r.Max.X > s.Max.X {
		r.Max.X = s.Max.X
	}
	if r.Max.Y > s.Max.Y {
		r.Max.Y = s.Max.Y
	}
	// Letting r0 and s0 be the values of r and s at the time that the method
	// is called, this next line is equivalent to:
	//
	// if max(r0.Min.X, s0.Min.X) >= min(r0.Max.X, s0.Max.X) || likewiseForY { etc }
	if r.Empty() {
		return ZR{{ $camelCaseKey }}
	}
	return r
}

// Union returns the smallest rectangle that contains both r and s.
func (r {{ $rectangleName }}) Union(s {{ $rectangleName }}) {{ $rectangleName }} {
	if r.Empty() {
		return s
	}
	if s.Empty() {
		return r
	}
	if r.Min.X > s.Min.X {
		r.Min.X = s.Min.X
	}
	if r.Min.Y > s.Min.Y {
		r.Min.Y = s.Min.Y
	}
	if r.Max.X {{ "<" | Unescaped }} s.Max.X {
		r.Max.X = s.Max.X
	}
	if r.Max.Y {{ "<" | Unescaped }} s.Max.Y {
		r.Max.Y = s.Max.Y
	}
	return r
}

// Empty reports whether the rectangle contains no points.
func (r {{ $rectangleName }}) Empty() bool {
	return r.Min.X >= r.Max.X || r.Min.Y >= r.Max.Y
}

// Eq reports whether r and s contain the same set of points. All empty
// rectangles are considered equal.
func (r {{ $rectangleName }}) Eq(s {{ $rectangleName }}) bool {
	return r == s || r.Empty() && s.Empty()
}

// Overlaps reports whether r and s have a non-empty intersection.
func (r {{ $rectangleName }}) Overlaps(s {{ $rectangleName }}) bool {
	return !r.Empty() && !s.Empty() &&
		r.Min.X {{ "<" | Unescaped }} s.Max.X && s.Min.X {{ "<" | Unescaped }} r.Max.X &&
		r.Min.Y {{ "<" | Unescaped }} s.Max.Y && s.Min.Y {{ "<" | Unescaped }} r.Max.Y
}

// In reports whether every point in r is in s.
func (r {{ $rectangleName }}) In(s {{ $rectangleName }}) bool {
	if r.Empty() {
		return true
	}
	// Note that r.Max is an exclusive bound for r, so that r.In(s)
	// does not require that r.Max.In(s).
	return s.Min.X {{ "<=" | Unescaped }} r.Min.X && r.Max.X {{ "<=" | Unescaped }} s.Max.X &&
		s.Min.Y {{ "<=" | Unescaped }} r.Min.Y && r.Max.Y {{ "<=" | Unescaped }} s.Max.Y
}

func (r {{ $rectangleName }}) Bounds() {{ $rectangleName }} {
	return r
}

// Expanded returns a rectangle that has been expanded in the x-direction
// by margin.X, and in y-direction by margin.Y. The resulting rectangle may be empty.
func (r {{ $rectangleName }}) Expanded(margin {{ $pointName }}) {{ $rectangleName }} {
	return {{ $rectangleName }}{
		{{ $pointName }}{r.Min.X - margin.X, r.Min.Y - margin.Y},
		{{ $pointName }}{r.Max.X + margin.X, r.Max.Y + margin.Y},
	}
}

func (r {{ $rectangleName }}) ExpandedByMargin(margin {{ .Key }}) {{ $rectangleName }} {
	return r.Expanded(Pt{{ $camelCaseKey }}(margin, margin))
}

// ZR{{ $camelCaseKey }} is the zero {{ $rectangleName }}.
var ZR{{ $camelCaseKey }} {{ $rectangleName }}

// Rect{{ $camelCaseKey }} is shorthand for {{ $rectangleName }}{Pt(x0, y0), Pt(x1, y1)}. The returned
// rectangle has minimum and maximum coordinates swapped if necessary so that
// it is well-formed.
func Rect{{ $camelCaseKey }}(x0, y0, x1, y1 {{ .Key }}) {{ $rectangleName }} {
	if x0 > x1 {
		x0, x1 = x1, x0
	}
	if y0 > y1 {
		y0, y1 = y1, y0
	}
	return {{ $rectangleName }}{{ "{" | Unescaped }}{{ $pointName }}{x0, y0}, {{ $pointName }}{x1, y1}}
}

// Rect{{ $camelCaseKey }}FromCenterSize constructs a rectangle with the given center and size.
// Both dimensions of size must be non-negative.
func Rect{{ $camelCaseKey }}FromCenterSize(center, size {{ $pointName }}) {{ $rectangleName }} {
	return Rect{{ $camelCaseKey }}(center.X-size.X, center.Y-center.Y, center.X+size.X, center.Y+size.Y)
}

// HelixRectRangeFromCenterAndMargin{{ $camelCaseKey }} 由center节点逆时针螺旋由内向外访问margin区域内的所有节点
// 25   24   23   22   21
// 10    9    8    7   20
// 11    2    1    6   19
// 12    3    4    5   18
// 13   14   15   16   17
func HelixRectRangeFromCenterAndMargin{{ $camelCaseKey }}(center {{ $pointName }}, margin {{ .Key }}, with func(p {{ $pointName }}) bool) {
	var x, y, xNow, yNow {{ .Key }}
	xLen, yLen := {{ .Key }}(1), {{ .Key }}(1)
	rectXYLen := margin*2 + 1
	m, max := {{ .Key }}(0), rectXYLen*rectXYLen
	startX, startY := center.X, center.Y

	for m {{ "<=" | Unescaped }} max {
		for x = startX; x >= startX-xLen; x-- {
			m++
			if m > max || !with(Pt{{ $camelCaseKey }}(x, startY)) {
				return
			}
		}
		for y = startY - 1; y >= startY-yLen; y-- {
			m++
			if m > max || !with(Pt{{ $camelCaseKey }}(x+1, y)) {
				return
			}
		}
		xLen++
		yLen++
		for xNow = x + 2; xNow {{ "<=" | Unescaped }} x+xLen; xNow++ {
			m++
			if m > max || !with(Pt{{ $camelCaseKey }}(xNow, y+1)) {
				return
			}
		}
		for yNow = y + 1; yNow {{ "<=" | Unescaped }} y+yLen; yNow++ {
			m++
			if m > max || !with(Pt{{ $camelCaseKey }}(xNow, yNow)) {
				return
			}
		}
		xLen++
		yLen++
		startX = xNow
		startY = yNow
	}
}
`
