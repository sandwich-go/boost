// Code generated by gotemplate. DO NOT EDIT.

package xtime

import (
	"sort"
	"sync"
	"time"
)

//template type SyncMap(KType,VType)

type WheelMap struct {
	sm     sync.Map
	locker sync.RWMutex
}

func NewWheelMap() *WheelMap {
	return &WheelMap{}
}

func (s *WheelMap) Keys() (ret []time.Duration) {
	s.sm.Range(func(key, value interface{}) bool {
		ret = append(ret, key.(time.Duration))
		return true
	})
	return ret
}

func (s *WheelMap) Len() (c int) {
	s.sm.Range(func(key, value interface{}) bool {
		c++
		return true
	})
	return c
}

func (s *WheelMap) Contains(key time.Duration) (ok bool) {
	_, ok = s.Load(key)
	return
}

func (s *WheelMap) Get(key time.Duration) (value *Wheel) {
	value, _ = s.Load(key)
	return
}

func (s *WheelMap) Load(key time.Duration) (value *Wheel, loaded bool) {
	if v, ok := s.sm.Load(key); ok {
		return v.(*Wheel), true
	}
	return
}
func (s *WheelMap) DeleteMultiple(keys ...time.Duration) {
	for _, k := range keys {
		s.sm.Delete(k)
	}
}
func (s *WheelMap) Clear() {
	s.sm.Range(func(key, value interface{}) bool {
		s.sm.Delete(key)
		return true
	})
}
func (s *WheelMap) Delete(key time.Duration)            { s.sm.Delete(key) }
func (s *WheelMap) Store(key time.Duration, val *Wheel) { s.sm.Store(key, val) }
func (s *WheelMap) LoadAndDelete(key time.Duration) (value *Wheel, loaded bool) {
	if v, ok := s.sm.LoadAndDelete(key); ok {
		return v.(*Wheel), true
	}
	return
}
func (s *WheelMap) GetOrSetFuncErrorLock(key time.Duration, cf func(key time.Duration) (*Wheel, error)) (value *Wheel, loaded bool, err error) {
	return s.LoadOrStoreFuncErrorLock(key, cf)
}

func (s *WheelMap) LoadOrStoreFuncErrorLock(key time.Duration, cf func(key time.Duration) (*Wheel, error)) (value *Wheel, loaded bool, err error) {
	if v, ok := s.Load(key); ok {
		return v, true, nil
	}
	s.locker.Lock()
	defer s.locker.Unlock()
	// 再次重试，如果获取到则直接返回
	if v, ok := s.Load(key); ok {
		return v, true, nil
	}
	value, err = cf(key)
	if err != nil {
		return value, false, err
	}
	s.Store(key, value)
	return value, false, nil
}

func (s *WheelMap) GetOrSetFuncLock(key time.Duration, cf func(key time.Duration) *Wheel) (value *Wheel, loaded bool) {
	return s.LoadOrStoreFuncLock(key, cf)
}

func (s *WheelMap) LoadOrStoreFuncLock(key time.Duration, cf func(key time.Duration) *Wheel) (value *Wheel, loaded bool) {
	value, loaded, _ = s.LoadOrStoreFuncErrorLock(key, func(key time.Duration) (*Wheel, error) {
		return cf(key), nil
	})
	return value, loaded
}

func (s *WheelMap) LoadOrStore(key time.Duration, val *Wheel) (*Wheel, bool) {
	actual, ok := s.sm.LoadOrStore(key, val)
	return actual.(*Wheel), ok
}

func (s *WheelMap) Range(f func(key time.Duration, value *Wheel) bool) {
	s.sm.Range(func(k, v interface{}) bool {
		return f(k.(time.Duration), v.(*Wheel))
	})
}

func (s *WheelMap) RangeDeterministic(f func(key time.Duration, value *Wheel) bool, sortableGetter func([]time.Duration) sort.Interface) {
	var keys []time.Duration
	s.sm.Range(func(key, value interface{}) bool {
		keys = append(keys, key.(time.Duration))
		return true
	})
	sort.Sort(sortableGetter(keys))
	for _, k := range keys {
		if v, ok := s.Load(k); ok {
			if !f(k, v) {
				break
			}
		}
	}
}
