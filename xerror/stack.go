package xerror

import (
	"fmt"
	"io"
	"runtime"
	"strings"
)

const (
	// maxStackDepth marks the max stack depth for error back traces.
	maxStackDepth = 32
)

// stack represents a stack of program counters.
type stack []uintptr

func callersCheckIsErrorWithStack(skip ...int) stack {
	if !IsErrorWithStack {
		return nil
	}
	return callers(skip...)
}

// callers returns the stack callers.
func callers(skip ...int) stack {
	var (
		pcs [maxStackDepth]uintptr
		n   = 3
	)
	if len(skip) > 0 {
		n += skip[0]
	}
	return pcs[:runtime.Callers(n, pcs[:])]
}

// formatSubStack formats the stack for error.
func formatSubStack(st stack, buffer io.StringWriter) {
	index := 1
	space := "  "
	for _, p := range st {
		if fn := runtime.FuncForPC(p - 1); fn != nil {
			file, line := fn.FileLine(p - 1)
			if strings.Contains(file, "<") { // like "<autogenerated>"
				continue
			}
			if goRootForFilter != "" && len(file) >= len(goRootForFilter) && file[0:len(goRootForFilter)] == goRootForFilter { // go root
				continue
			}
			if index > 9 {
				space = " "
			}
			_, _ = buffer.WriteString(fmt.Sprintf("   <%d>:%s%s\n    \t%s:%d\n", index, space, fn.Name(), file, line))
			index++
		}
	}
}
